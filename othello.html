<!doctype html>
<meta charset="utf-8">
<title>Othello</title>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.0.3/pixi.min.js"></script>
    <script>
    let status = [
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1,  0,  1, -1, -1, -1],
        [-1, -1, -1,  1,  0, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1]
    ];
    const BLACK = 0, WHITE = 1;
    var turn = BLACK;
    let white_pieces = [];
    let black_pieces = [];
    let trans_pieces = [];
    let playable_pieces = [];
    let mass_size = 100;

    let Application = PIXI.Application,
    Container = PIXI.Container,
    loader = PIXI.Loader.shared,
    resources = PIXI.Loader.shared.resources,
    TextureCache = PIXI.utils.TextureCache,
    Sprite = PIXI.Sprite,
    Rectangle = PIXI.Rectangle,
    Point = PIXI.Point,
    TextStyle = PIXI.TextStyle,
    Text = PIXI.Text;

    let app = new Application({
        width: 800,
        height: 800,
        antialiasing: true,
        transparent: false,
        resolution: 1
    });

    let style = new TextStyle({
        fontFamily: "Arial",
        fontSize: 36,
        fill: "white",
        stroke: '#ff3300',
        strokeThickness: 4,
        dropShadow: true,
        dropShadowColor: "#000000",
        dropShadowBlur: 4,
        dropShadowAngle: Math.PI / 6,
        dropShadowDistance: 6,
    });

    document.body.appendChild(app.view);

    loader
    .add([
        "images/board.png",
        "images/white.png",
        "images/black.png",
        "images/black_T.png",
        "images/white_T.png"
    ])
    .load(setup);

    /*
    Judege if point can be put
    */
    function judgePoint(point){
        if (status[point.x][point.y] >= 0){
            return -1;
        }
        let direction = {
            coord : new Point(-1, -1),
            turn : turn,
            playable : 0,
            left : -1,
            left_up : -1,
            up : -1,
            right_up : -1,
            right : -1,
            right_down : -1,
            down : -1,
            left_down : -1
        };

        //left
        let x = point.x, y = point.y - 1;
        if (y >= 0 && status[x][y] + turn == 1){ //Enenmy mass
            y--;
            while(y >= 0){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left = turn;
                    break;
                }
                y--;
            }
        }

        //left-up
        x = point.x - 1, y = point.y - 1;
        if (x >= 0 && y >= 0 && status[x][y] + turn == 1){ //Enenmy mass
            x--, y--;
            while(x >= 0 && y >= 0){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left_up = turn;
                    break;
                }
                x--, y--;
            }
        }

        //up
        x = point.x - 1, y = point.y;
        if (x >= 0 && status[x][y] + turn == 1){ //Enenmy mass
            x--;
            while(x >= 0){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.up = turn;
                    break;
                }
                x--;
            }
        }

        //right-up
        x = point.x - 1, y = point.y + 1;
        if (x >= 0 && y < 8 && status[x][y] + turn == 1){ //Enenmy mass
            x--, y++;
            while(x >= 0 && y < 8){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.right_up = turn;
                    break;
                }
                x--, y++;
            }
        }

        //right
        x = point.x, y = point.y + 1;
        if (y < 8 && status[x][y] + turn == 1){ //Enenmy mass
            y++;
            while(y < 8){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.right = turn;
                    break;
                }
                y++;
            }
        }

        //right-down
        x = point.x + 1, y = point.y + 1;
        if (x < 8 && y < 8 && status[x][y] + turn == 1){ //Enenmy mass
            x++, y++;
            while(y < 8 && x < 8){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.right_down = turn;
                    break;
                }
                x++, y++;
            }
        }

        //down
        x = point.x + 1, y = point.y;
        if (x < 8 && status[x][y] + turn == 1){ //Enenmy mass
            x++;
            while(x < 8){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.down = turn;
                    break;
                }
                x++;
            }
        }

        //left-down
        x = point.x + 1, y = point.y - 1;
        if (x < 8 && y >= 0 && status[x][y] + turn == 1){ //Enenmy mass
            x++, y--;
            while(x < 8 && y >= 0){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left_down = turn;
                    break;
                }
                x++, y--;
            }
        }

        if (direction.playable > 0) {
            direction.coord = new Point(point.x, point.y);
        }

        return direction;
    }

    function printArray(arr){
        for (var i = 0; i < arr.length; i++) {
            console.log(arr[i]);
        }
    }

    function removeTransPieces(){
        let length = trans_pieces.length;
        for (let i = 0; i < length; i++) {
            app.stage.removeChild(trans_pieces.pop());
            playable_pieces.pop();
        }
    }

    function showTransPieces(){
        let direction;

        removeTransPieces();
        for (let i = 0; i < status.length; i++) {
            for (let j = 0; j < status[i].length; j++) {
                let point = new Point(i, j);
                direction = judgePoint(point);
                // console.log("x: "+i+" y: "+j+"  ");
                // console.log(direction);
                if (direction.playable > 0){
                    playable_pieces.push(direction);
                    if (direction.turn == BLACK){
                        let black_piece = new Sprite(resources["images/black_T.png"].texture);
                        trans_pieces.push(black_piece);
                        app.stage.addChild(black_piece);
                        black_piece.position.set(i*mass_size, j*mass_size);
                    }else if (direction.turn == WHITE){
                        let white_piece = new Sprite(resources["images/white_T.png"].texture);
                        trans_pieces.push(white_piece);
                        app.stage.addChild(white_piece);
                        white_piece.position.set(i*mass_size, j*mass_size);
                    }
                }
            }
        }
    }

    function checkPalyable(point) {
        // console.log(point.x, point.y);
        for (let i = 0; i < playable_pieces.length; i++) {
            if (playable_pieces[i].coord.x == point.x && playable_pieces[i].coord.y == point.y){
                return true;
            }
        }
        return false;
    }

    /*

    Who is WINNER

    */
    function checkWinner() {
        if (trans_pieces.length == 0) {
            return 1 - turn;
        }
        let white_n = 0, black_n = 0;
        for (let i = 0; i < status.length; i++){
            for (let j = 0; j < status[i].length; j++){
                if (status[i][j] < 0){
                    return -1;
                }
                if (status[i][j] == BLACK){
                    black_n++;
                }else{
                    white_n++;
                }
            }
        }
        return black_n > white_n? BLACK : WHITE;
    }

    /*

    Game Over

    */
    function gameOver(winner) {
        let text;
        if (winner == BLACK) {
            text = "Black";
        }else{
            text = "White";
        }
        let message = new Text("Winner: "+text, style);
        message.x = app.stage.width / 2 - 100;
        message.y = app.stage.height / 2 - 32;
        app.stage.addChild(message);
    }

    /*

    REVERSE

    */
    function reversePieces(point) {
        let image;
        let direction;
        if (1 - turn == BLACK){
            image = "images/black.png";
        }else{
            image = "images/white.png";
        }

        for (var i = 0; i < playable_pieces.length; i++) {
            // console.log("--------------------------");
            // console.log(playable_pieces.length);
            // console.log(playable_pieces[i]);
            if (point.x == playable_pieces[i].coord.x && point.y == playable_pieces[i].coord.y){
                direction = playable_pieces[i];
                break;
            }
        }
        let x = 0, y = 0;
        // console.log(direction);
        // console.log(turn);
        //left
        if (direction.left == 1 - turn){
            x = point.x, y = point.y - 1;
            for (let i = 0; i < 8; i++) {
                if (status[x][y] == 1 - turn) {
                    break;
                }
                let black_piece = new Sprite(resources[image].texture);
                app.stage.addChild(black_piece);
                black_piece.position.set(x*mass_size, y*mass_size);
                status[x][y] = 1 - turn;
                y--;
            }
        }

        //left-up
        if (direction.left_up == 1 - turn){
            x = point.x - 1, y = point.y - 1;
            for (let i = 0; i < 8; i++){
                if (status[x][y] == 1 - turn) {
                    break;
                }
                let black_piece = new Sprite(resources[image].texture);
                app.stage.addChild(black_piece);
                black_piece.position.set(x*mass_size, y*mass_size);
                status[x][y] = 1 - turn;
                x--, y--;
            }
        }

        //up
        if (direction.up == 1 - turn){
            x = point.x - 1, y = point.y;
            for (let i = 0; i < 8; i++){
                if (status[x][y] == 1 - turn) {
                    break;
                }
                let black_piece = new Sprite(resources[image].texture);
                app.stage.addChild(black_piece);
                black_piece.position.set(x*mass_size, y*mass_size);
                status[x][y] = 1 - turn;
                x--;
            }
        }

        //right-up
        if (direction.right_up == 1 - turn){
            x = point.x - 1, y = point.y + 1;
            for (let i = 0; i < 8; i++){
                if (status[x][y] == 1 - turn) {
                    break;
                }
                let black_piece = new Sprite(resources[image].texture);
                app.stage.addChild(black_piece);
                black_piece.position.set(x*mass_size, y*mass_size);
                status[x][y] = 1 - turn;
                x--, y++;
            }
        }

        //right
        if (direction.right == 1 - turn){
            x = point.x, y = point.y + 1;
            for (let i = 0; i < 8; i++){
                if (status[x][y] == 1 - turn) {
                    break;
                }
                let black_piece = new Sprite(resources[image].texture);
                app.stage.addChild(black_piece);
                black_piece.position.set(x*mass_size, y*mass_size);
                status[x][y] = 1 - turn;
                y++;
            }
        }

        //right-down
        if (direction.right_down == 1 - turn){
            x = point.x + 1, y = point.y + 1;
            for (let i = 0; i < 8; i++){
                if (status[x][y] == 1 - turn) {
                    break;
                }
                let black_piece = new Sprite(resources[image].texture);
                app.stage.addChild(black_piece);
                black_piece.position.set(x*mass_size, y*mass_size);
                status[x][y] = 1 - turn;
                x++, y++;
            }
        }

        //down
        if (direction.down == 1 - turn){
            x = point.x + 1, y = point.y;
            for (let i = 0; i < 8; i++){
                if (status[x][y] == 1 - turn) {
                    break;
                }
                let black_piece = new Sprite(resources[image].texture);
                app.stage.addChild(black_piece);
                black_piece.position.set(x*mass_size, y*mass_size);
                status[x][y] = 1 - turn;
                x++;
            }
        }

        //left-down
        if (direction.left_down == 1 - turn){
            x = point.x + 1, y = point.y - 1;
            for (let i = 0; i < 8; i++){
                if (status[x][y] == 1 - turn) {
                    break;
                }
                let black_piece = new Sprite(resources[image].texture);
                app.stage.addChild(black_piece);
                black_piece.position.set(x*mass_size, y*mass_size);
                status[x][y] = 1 - turn;
                x++, y--;
            }
        }
    }

    /*

    Click Event

    */
    function Clicked(event) {
        const point = event.data.getLocalPosition(this.parent);
        let piece_pos = new PIXI.Point(Math.floor(point.x / 100), Math.floor(point.y / 100));
        // console.log(piece_pos);
        if (!checkPalyable(piece_pos)){
            return;
        }

        if (turn == BLACK){
            black_pieces[black_pieces.length] = new Sprite(resources["images/black.png"].texture);
            app.stage.addChild(black_pieces[black_pieces.length-1]);
            status[piece_pos.x][piece_pos.y] = turn;
            black_pieces[black_pieces.length-1].position.set(piece_pos.x*mass_size, piece_pos.y*mass_size);
            //app.stage.removeChild(black_piece_poss[count-1]);
            turn = WHITE;
        }else if (turn == WHITE){
            white_pieces[white_pieces.length] = new Sprite(resources["images/white.png"].texture);
            app.stage.addChild(white_pieces[white_pieces.length-1]);
            status[piece_pos.x][piece_pos.y] = turn;
            white_pieces[white_pieces.length-1].position.set(piece_pos.x*mass_size, piece_pos.y*mass_size);
            //app.stage.removeChild(white_piece_poss[count-1]);
            turn = BLACK;
        }
        reversePieces(piece_pos);
        showTransPieces();
        let winner = checkWinner();
        if (winner >= 0){
            gameOver(winner);
        }
        // printArray(status);
    }

    function initStatus() {
        let board = new Sprite(resources["images/board.png"].texture);
        app.stage.addChild(board);
        board.interactive = true;
        board.on('click', Clicked);

        white_pieces[0] = new Sprite(resources["images/white.png"].texture);
        white_pieces[1] = new Sprite(resources["images/white.png"].texture);
        black_pieces[0] = new Sprite(resources["images/black.png"].texture);
        black_pieces[1] = new Sprite(resources["images/black.png"].texture);

        app.stage.addChild(white_pieces[0]);
        app.stage.addChild(black_pieces[0]);
        app.stage.addChild(white_pieces[1]);
        app.stage.addChild(black_pieces[1]);

        white_pieces[0].position.set(4*mass_size, 3*mass_size);
        white_pieces[1].position.set(3*mass_size, 4*mass_size);
        black_pieces[0].position.set(3*mass_size, 3*mass_size);
        black_pieces[1].position.set(4*mass_size, 4*mass_size);
    }

    function setup() {
        initStatus();
        showTransPieces();
    }

</script>
</body>
