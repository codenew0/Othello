<!doctype html>
<meta charset="utf-8">
<title>Make a sprite from a texture atlas</title>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.0.3/pixi.min.js"></script>
    <script>
    let status = [
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, WHITE, BLACK, -1, -1, -1],
        [-1, -1, -1, BLACK, WHITE, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1]
    ];
    const WHITE = 0, BLACK = 1;
    var turn = BLACK;
    let white_pieces = [];
    let black_pieces = [];
    let mass_size = 100;

    let Application = PIXI.Application,
    Container = PIXI.Container,
    loader = PIXI.Loader.shared,
    resources = PIXI.Loader.shared.resources,
    TextureCache = PIXI.utils.TextureCache,
    Sprite = PIXI.Sprite,
    Rectangle = PIXI.Rectangle,
    Point = PIXI.Point;

    let app = new Application({
        width: 800,
        height: 800,
        antialiasing: true,
        transparent: false,
        resolution: 1
    });

    document.body.appendChild(app.view);

    loader
    .add([
        "images/board.png",
        "images/white.png",
        "images/black.png"
    ])
    .load(setup);

    function negaSlope(){
        let pair = {
            my_mass : [],
            empty_mass : []
        };
        let check_in = 0;
        for (var i = status.length - 3; i >= 0; i--) {
            let m = i, n = 0;
            while (m < 8){
                if (status[n][m] < 0){  //find empty mass (E)
                    check_in = 1;
                    pair.empty_mass[empty_mass.length] = new Point(n, m);
                }
                if (check_in == 1 && status[n][m] != turn){     //empty mass -> enemy mass (EX)
                    check_in = 2;
                }else if (check_in == 2 && status[n][m] == turn){ //empty mass -> enemy mass -> my mass(EXXXO)
                    check_in = 3;
                    pair.my_mass[my_mass.length] = new Point(n, m);
                }
                if (check_in > 0 && check_in < 3) {    //found playable mass
                    pair.empty_mass.pop();
                }
                m++, n++;
            }
            check_in = 0;
            let x = i, y = 0;
            while (x < 8){
                if (status[x][y] < 0){  //find empty mass (E)
                    check_in = 1;
                    pair.empty_mass[empty_mass.length] = new Point(x, y);
                }
                if (check_in == 1 && status[x][y] != turn){     //empty mass -> enemy mass (EX)
                    check_in = 2;
                }else if (check_in == 2 && status[x][y] == turn){ //empty mass -> enemy mass -> my mass(EXXXO)
                    check_in = 3;
                    pair.my_mass[my_mass.length] = new Point(x, y);
                }
                if (check_in > 0 && check_in < 3) {    //found playable mass
                    pair.empty_mass.pop();
                }
                x++, y++;
            }
            check_in = 0;
        }
        return pair;
    }

    function posiSlope(){
        let pair = {
            my_mass : [],
            empty_mass : []
        };
        let check_in = 0;
        for (var i = 3; i < status.length; i++) {
            let m = i, n = 0;
            while (m >= 0){
                if (status[n][m] < 0){  //find empty mass (E)
                    check_in = 1;
                    pair.empty_mass[empty_mass.length] = new Point(n, m);
                }
                if (check_in == 1 && status[n][m] != turn){     //empty mass -> enemy mass (EX)
                    check_in = 2;
                }else if (check_in == 2 && status[n][m] == turn){ //empty mass -> enemy mass -> my mass(EXXXO)
                    check_in = 3;
                    pair.my_mass[my_mass.length] = new Point(n, m);
                }
                if (check_in > 0 && check_in < 3) {    //found playable mass
                    pair.empty_mass.pop();
                }
                m++, n++;
            }
            check_in = 0;
            let x = i, y = 0;
            while (x < 8){
                if (status[x][y] < 0){  //find empty mass (E)
                    check_in = 1;
                    pair.empty_mass[empty_mass.length] = new Point(x, y);
                }
                if (check_in == 1 && status[x][y] != turn){     //empty mass -> enemy mass (EX)
                    check_in = 2;
                }else if (check_in == 2 && status[x][y] == turn){ //empty mass -> enemy mass -> my mass(EXXXO)
                    check_in = 3;
                    pair.my_mass[my_mass.length] = new Point(x, y);
                }
                if (check_in > 0 && check_in < 3) {    //found playable mass
                    pair.empty_mass.pop();
                }
                x++, y++;
            }
            check_in = 0;
        }
        return pair;
    }

    function printArray(arr){
        for (var i = 0; i < arr.length; i++) {
            console.log(arr[i]);
        }
    }

    function has_piece(piece_pos){
        if (status[piece_pos.x][piece_pos.y] < 0){
            status[piece_pos.x][piece_pos.y] = turn;
            return false;
        }else{
            return true;
        }
    }

    function Clicked(event) {
        const point = event.data.getLocalPosition(this.parent);
        let piece_pos = new PIXI.Point(Math.floor(point.x / 100), Math.floor(point.y / 100));
        if (has_piece(piece_pos)){
            return;
        }
        console.log(piece_pos.x, piece_pos.y);

        if (turn == BLACK){
            black_pieces[black_pieces.length] = new Sprite(resources["images/black.png"].texture);
            app.stage.addChild(black_pieces[black_pieces.length-1]);
            black_pieces[black_pieces.length-1].position.set(piece_pos.x*mass_size, piece_pos.y*mass_size);
            //app.stage.removeChild(black_piece_poss[count-1]);
            turn = WHITE;
        }else if (turn == WHITE){
            white_pieces[white_pieces.length] = new Sprite(resources["images/white.png"].texture);
            app.stage.addChild(white_pieces[white_pieces.length-1]);
            white_pieces[white_pieces.length-1].position.set(piece_pos.x*mass_size, piece_pos.y*mass_size);
            //app.stage.removeChild(white_piece_poss[count-1]);
            turn = BLACK;
        }
    }

    function initStatus() {
        let board = new Sprite(resources["images/board.png"].texture);
        app.stage.addChild(board);
        board.interactive = true;
        board.on('click', Clicked);

        white_pieces[0] = new Sprite(resources["images/white.png"].texture);
        white_pieces[1] = new Sprite(resources["images/white.png"].texture);
        black_pieces[0] = new Sprite(resources["images/black.png"].texture);
        black_pieces[1] = new Sprite(resources["images/black.png"].texture);

        app.stage.addChild(white_pieces[0]);
        app.stage.addChild(black_pieces[0]);
        app.stage.addChild(white_pieces[1]);
        app.stage.addChild(black_pieces[1]);

        white_pieces[0].position.set(3*mass_size, 3*mass_size);
        white_pieces[1].position.set(4*mass_size, 4*mass_size);
        black_pieces[0].position.set(3*mass_size, 4*mass_size);
        black_pieces[1].position.set(4*mass_size, 3*mass_size);
    }

    function setup() {
        initStatus();
    }

</script>
</body>
