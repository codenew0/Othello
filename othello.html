<!doctype html>
<meta charset="utf-8">
<title>Make a sprite from a texture atlas</title>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.0.3/pixi.min.js"></script>
    <script>
    let status = [
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1,  0,  1, -1, -1, -1],
        [-1, -1, -1,  1,  0, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1]
    ];
    const WHITE = 0, BLACK = 1;
    var turn = BLACK;
    let white_pieces = [];
    let black_pieces = [];
    let mass_size = 100;

    let Application = PIXI.Application,
    Container = PIXI.Container,
    loader = PIXI.Loader.shared,
    resources = PIXI.Loader.shared.resources,
    TextureCache = PIXI.utils.TextureCache,
    Sprite = PIXI.Sprite,
    Rectangle = PIXI.Rectangle,
    Point = PIXI.Point;

    let app = new Application({
        width: 800,
        height: 800,
        antialiasing: true,
        transparent: false,
        resolution: 1
    });

    document.body.appendChild(app.view);

    loader
    .add([
        "images/board.png",
        "images/white.png",
        "images/black.png",
        "images/black_T.png",
        "images/white_T.png"
    ])
    .load(setup);

    /*
    Judege if point can be put
    */
    function judgePoint(point){
        if (status[point.x][point.y] >= 0){
            return -1;
        }
        let direction = {
            turn: turn,
            playable: 0,
            left : -1,
            left_up : -1,
            up : -1,
            right_up : -1,
            right : -1,
            right_down : -1,
            down : -1,
            left_down : -1
        };

        //left
        let x = point.x, y = point.y - 1;
        if (y >= 0 && status[x][y] + turn == 1){ //Enenmy mass
            y--;
            while(y >= 0){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left = turn;
                    break;
                }
                y--;
            }
        }

        //left-up
        x = point.x - 1, y = point.y - 1;
        if (x >= 0 && y >= 0 && status[x][y] + turn == 1){ //Enenmy mass
            x--, y--;
            while(x >= 0 && y >= 0){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left = turn;
                    break;
                }
                x--, y--;
            }
        }

        //up
        x = point.x - 1, y = point.y;
        if (x >= 0 && status[x][y] + turn == 1){ //Enenmy mass
            x--;
            while(x >= 0){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left = turn;
                    break;
                }
                x--;
            }
        }

        //right-up
        x = point.x - 1, y = point.y + 1;
        if (x >= 0 && y < 8 && status[x][y] + turn == 1){ //Enenmy mass
            x--, y++;
            while(x >= 0 && y < 8){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left = turn;
                    break;
                }
                x--, y++;
            }
        }

        //right
        x = point.x, y = point.y + 1;
        if (y < 8 && status[x][y] + turn == 1){ //Enenmy mass
            y++;
            while(y < 8){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left = turn;
                    break;
                }
                y++;
            }
        }

        //right-down
        x = point.x + 1, y = point.y + 1;
        if (x < 8 && y < 8 && status[x][y] + turn == 1){ //Enenmy mass
            x++, y++;
            while(y < 8){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left = turn;
                    break;
                }
                x++, y++;
            }
        }

        //down
        x = point.x + 1, y = point.y;
        if (x < 8 && status[x][y] + turn == 1){ //Enenmy mass
            x++;
            while(y < 8){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left = turn;
                    break;
                }
                x++;
            }
        }

        //left-down
        x = point.x + 1, y = point.y - 1;
        if (x < 8 && y >= 0 && status[x][y] + turn == 1){ //Enenmy mass
            x++, y--;
            while(y < 8){
                if (status[x][y] == -1){
                    break;
                }else if (status[x][y] == turn){
                    direction.playable++;
                    direction.left = turn;
                    break;
                }
                x++, y--;
            }
        }

        return direction;
    }
    /*
    k = -1
    */
    function negaSlope(){
        let pair = {
            my_mass : [],
            empty_mass : []
        };
        let check_in = 0;
        for (var i = status.length - 3; i >= 0; i--) {
            let m = i, n = 0;
            while (m < 8){
                if (status[n][m] < 0){  //find empty mass (E)
                    check_in = 1;
                    pair.empty_mass[empty_mass.length] = new Point(n, m);
                }
                if (check_in == 1 && status[n][m] != turn){     //empty mass -> enemy mass (EX)
                    check_in = 2;
                }else if (check_in == 2 && status[n][m] == turn){ //empty mass -> enemy mass -> my mass(EXXXO)
                    check_in = 3;
                    pair.my_mass[my_mass.length] = new Point(n, m);
                }
                if (check_in > 0 && check_in < 3) {    //found playable mass
                    pair.empty_mass.pop();
                }
                m++, n++;
            }
            check_in = 0;
            let x = i, y = 0;
            while (x < 8){
                if (status[x][y] < 0){  //find empty mass (E)
                    check_in = 1;
                    pair.empty_mass[empty_mass.length] = new Point(x, y);
                }
                if (check_in == 1 && status[x][y] != turn){     //empty mass -> enemy mass (EX)
                    check_in = 2;
                }else if (check_in == 2 && status[x][y] == turn){ //empty mass -> enemy mass -> my mass(EXXXO)
                    check_in = 3;
                    pair.my_mass[my_mass.length] = new Point(x, y);
                }
                if (check_in > 0 && check_in < 3) {    //found playable mass
                    pair.empty_mass.pop();
                }
                x++, y++;
            }
            check_in = 0;
        }
        return pair;
    }

    /*
    k = 1
    */
    function posiSlope(){
        let pair = {
            my_mass : [],
            empty_mass : []
        };
        let check_in = 0;
        for (var i = 3; i < status.length; i++) {
            let m = i, n = 0;
            while (m >= 0){
                if (status[n][m] < 0){  //find empty mass (E)
                    check_in = 1;
                    pair.empty_mass[empty_mass.length] = new Point(n, m);
                }
                if (check_in == 1 && status[n][m] != turn){     //empty mass -> enemy mass (EX)
                    check_in = 2;
                }else if (check_in == 2 && status[n][m] == turn){ //empty mass -> enemy mass -> my mass(EXXXO)
                    check_in = 3;
                    pair.my_mass[my_mass.length] = new Point(n, m);
                }
                if (check_in > 0 && check_in < 3) {    //found playable mass
                    pair.empty_mass.pop();
                }
                m--, n++;
            }
            check_in = 0;
            let x = i, y = 0;
            while (x < 8){
                if (status[x][y] < 0){  //find empty mass (E)
                    check_in = 1;
                    pair.empty_mass[empty_mass.length] = new Point(x, y);
                }
                if (check_in == 1 && status[x][y] != turn){     //empty mass -> enemy mass (EX)
                    check_in = 2;
                }else if (check_in == 2 && status[x][y] == turn){ //empty mass -> enemy mass -> my mass(EXXXO)
                    check_in = 3;
                    pair.my_mass[my_mass.length] = new Point(x, y);
                }
                if (check_in > 0 && check_in < 3) {    //found playable mass
                    pair.empty_mass.pop();
                }
                x++, y++;
            }
            check_in = 0;
        }
        return pair;
    }

    function printArray(arr){
        for (var i = 0; i < arr.length; i++) {
            console.log(arr[i]);
        }
    }

    function has_piece(piece_pos){
        if (status[piece_pos.x][piece_pos.y] < 0){
            status[piece_pos.x][piece_pos.y] = turn;
            return false;
        }else{
            return true;
        }
    }

    function Clicked(event) {
        const point = event.data.getLocalPosition(this.parent);
        let piece_pos = new PIXI.Point(Math.floor(point.x / 100), Math.floor(point.y / 100));
        if (has_piece(piece_pos)){
            return;
        }
        console.log(piece_pos.x, piece_pos.y);

        if (turn == BLACK){
            black_pieces[black_pieces.length] = new Sprite(resources["images/black.png"].texture);
            app.stage.addChild(black_pieces[black_pieces.length-1]);
            black_pieces[black_pieces.length-1].position.set(piece_pos.x*mass_size, piece_pos.y*mass_size);
            //app.stage.removeChild(black_piece_poss[count-1]);
            turn = WHITE;
        }else if (turn == WHITE){
            white_pieces[white_pieces.length] = new Sprite(resources["images/white.png"].texture);
            app.stage.addChild(white_pieces[white_pieces.length-1]);
            white_pieces[white_pieces.length-1].position.set(piece_pos.x*mass_size, piece_pos.y*mass_size);
            //app.stage.removeChild(white_piece_poss[count-1]);
            turn = BLACK;
        }
    }

    function initStatus() {
        let board = new Sprite(resources["images/board.png"].texture);
        app.stage.addChild(board);
        board.interactive = true;
        board.on('click', Clicked);

        white_pieces[0] = new Sprite(resources["images/white.png"].texture);
        white_pieces[1] = new Sprite(resources["images/white.png"].texture);
        black_pieces[0] = new Sprite(resources["images/black.png"].texture);
        black_pieces[1] = new Sprite(resources["images/black.png"].texture);

        app.stage.addChild(white_pieces[0]);
        app.stage.addChild(black_pieces[0]);
        app.stage.addChild(white_pieces[1]);
        app.stage.addChild(black_pieces[1]);

        white_pieces[0].position.set(3*mass_size, 3*mass_size);
        white_pieces[1].position.set(4*mass_size, 4*mass_size);
        black_pieces[0].position.set(3*mass_size, 4*mass_size);
        black_pieces[1].position.set(4*mass_size, 3*mass_size);
    }

    function setup() {
        initStatus();
        let black_piece, white_piece, direction;

        loop:
        for (var i = 0; i < status.length; i++) {
            for (var j = 0; j < status[i].length; j++) {
                let point = new Point(i, j);
                direction = judgePoint(point);
                console.log("x: "+i+" y: "+j+"  ");
                console.log(direction);
                if (direction.playable > 0){
                    if (direction.turn == BLACK){
                        black_piece = new Sprite(resources["images/black_T.png"].texture);
                        app.stage.addChild(black_piece);
                        black_piece.position.set(i*mass_size, j*mass_size);
                    }else if (direction.turn == WHITE){
                        white_piece = new Sprite(resources["images/white_T.png"].texture);
                        app.stage.addChild(white_piece);
                        white_piece.position.set(i*mass_size, j*mass_size);
                    }
                }
            }
        }
        if (direction.playable > 0){
            if (direction.turn == BLACK){
                black_piece = new Sprite(resources["images/black_T.png"].texture);
                app.stage.addChild(black_piece);
                black_piece.position.set(i*mass_size, j*mass_size);
            }else if (direction.turn == WHITE){
                white_piece = new Sprite(resources["images/white_T.png"].texture);
                app.stage.addChild(white_piece);
                white_piece.position.set(i*mass_size, j*mass_size);
            }
        }
    }

</script>
</body>
